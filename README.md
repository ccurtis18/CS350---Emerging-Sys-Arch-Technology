# CS350---Emerging-Sys-Arch-Technology

The projects I completed in this course focused on developing a functional embedded system that could read temperature data, process it through a state machine, and display the results on an LCD screen. The goal was to simulate a smart thermostat system that could manage different temperature states and prepare for future integration with Wi-Fi or IoT functionality. This solved the problem of how to design and program a low-level system capable of reading, interpreting, and responding to environmental input in real time, while maintaining a structured and maintainable codebase.

One of the areas where I did particularly well was creating a clean and organized code structure. I made sure my functions were well separated, with clear responsibilities for hardware input, state transitions, and display output. This not only made the code easier to follow but also helped prevent errors during testing. I also took time to build a clear state machine diagram before coding, which helped me plan the logic flow and avoid confusion later in the project.

If there is an area where I could improve, it would be optimizing performance and exploring additional features like multiple sensor support or network communication. I would also like to gain more experience with low-level timing control, as that becomes increasingly important for real-time systems. These areas would strengthen my understanding of how software design directly affects hardware responsiveness.

Throughout this course, I added several tools and resources to my personal support network. I became more confident using GitHub for version control and portfolio management, learned to use draw.io for designing state-machine diagrams, and deepened my understanding of the Raspberry Pi GPIO library. I also found helpful documentation and tutorials that supported my learning, including official Python and hardware integration resources.

The skills I gained from this course are highly transferable to other projects and coursework. Understanding how to connect software logic to physical hardware can be applied to IoT development, robotics, and future courses that focus on systems programming or hardware interfaces. My experience structuring maintainable and modular code will also be useful for larger software projects that require readability and scalability.

To make my project maintainable, readable, and adaptable, I followed consistent naming conventions, added clear comments, and designed the program so that additional features could be added without rewriting the existing code. I kept the logic modular and separated concerns, which makes future testing and debugging much easier. By doing this, the project is now easy to understand not just for me, but also for anyone who reviews my portfolio later.
